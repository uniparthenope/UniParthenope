"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const application_manager_base_1 = require("../../application-manager-base");
const helpers_1 = require("../../../helpers");
const decorators_1 = require("../../../decorators");
const constants_1 = require("../../../constants");
const path = require("path");
const temp = require("temp");
const log4js = require("log4js");
class IOSSimulatorApplicationManager extends application_manager_base_1.ApplicationManagerBase {
    constructor($childProcess, iosSim, device, $options, $fs, $deviceLogProvider, $logger, $hooksService) {
        super($logger, $hooksService, $deviceLogProvider);
        this.$childProcess = $childProcess;
        this.iosSim = iosSim;
        this.device = device;
        this.$options = $options;
        this.$fs = $fs;
        this.$deviceLogProvider = $deviceLogProvider;
        this._lldbProcesses = {};
    }
    getInstalledApplications() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.iosSim.getInstalledApplications(this.device.deviceInfo.identifier);
        });
    }
    installApplication(packageFilePath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.$fs.exists(packageFilePath) && path.extname(packageFilePath) === ".zip") {
                temp.track();
                const dir = temp.mkdirSync("simulatorPackage");
                yield this.$fs.unzip(packageFilePath, dir);
                const app = _.find(this.$fs.readDirectory(dir), directory => path.extname(directory) === ".app");
                if (app) {
                    packageFilePath = path.join(dir, app);
                }
            }
            yield this.iosSim.installApplication(this.device.deviceInfo.identifier, packageFilePath);
        });
    }
    uninstallApplication(appIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.detachNativeDebugger(appIdentifier);
            return this.iosSim.uninstallApplication(this.device.deviceInfo.identifier, appIdentifier);
        });
    }
    startApplication(appData) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = appData.waitForDebugger ? {
                waitForDebugger: true,
                args: "--nativescript-debug-brk",
            } : {};
            yield this.setDeviceLogData(appData);
            const launchResult = yield this.iosSim.startApplication(this.device.deviceInfo.identifier, appData.appId, options);
            const pid = helpers_1.getPidFromiOSSimulatorLogs(appData.appId, launchResult);
            this.$deviceLogProvider.setApplicationPidForDevice(this.device.deviceInfo.identifier, pid);
            if (appData.waitForDebugger) {
                this.attachNativeDebugger(appData.appId, pid);
            }
        });
    }
    stopApplication(appData) {
        return __awaiter(this, void 0, void 0, function* () {
            const { appId } = appData;
            yield this.device.destroyDebugSocket(appId);
            yield this.detachNativeDebugger(appId);
            yield this.iosSim.stopApplication(this.device.deviceInfo.identifier, appData.appId, appData.projectName);
        });
    }
    getDebuggableApps() {
        return __awaiter(this, void 0, void 0, function* () {
            return [];
        });
    }
    getDebuggableAppViews(appIdentifiers) {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.resolve(null);
        });
    }
    attachNativeDebugger(appId, pid) {
        this._lldbProcesses[appId] = this.$childProcess.spawn("lldb", ["-p", pid]);
        if (log4js.levels.TRACE.isGreaterThanOrEqualTo(this.$logger.getLevel())) {
            this._lldbProcesses[appId].stdout.pipe(process.stdout);
        }
        this._lldbProcesses[appId].stderr.pipe(process.stderr);
        this._lldbProcesses[appId].stdin.write("process continue\n");
    }
    detachNativeDebugger(appId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._lldbProcesses[appId]) {
                this._lldbProcesses[appId].stdin.write("process detach\n");
                yield this.killProcess(this._lldbProcesses[appId]);
                this._lldbProcesses[appId] = undefined;
            }
        });
    }
    killProcess(childProcess) {
        return __awaiter(this, void 0, void 0, function* () {
            if (childProcess) {
                return new Promise((resolve, reject) => {
                    childProcess.on("close", resolve);
                    childProcess.kill();
                });
            }
        });
    }
    setDeviceLogData(appData) {
        return __awaiter(this, void 0, void 0, function* () {
            this.$deviceLogProvider.setProjectNameForDevice(this.device.deviceInfo.identifier, appData.projectName);
            this.$deviceLogProvider.setProjectDirForDevice(this.device.deviceInfo.identifier, appData.projectDir);
            if (!this.$options.justlaunch) {
                yield this.startDeviceLog();
            }
        });
    }
    startDeviceLog() {
        return this.device.openDeviceLogStream({ predicate: constants_1.IOS_LOG_PREDICATE });
    }
}
__decorate([
    helpers_1.hook('install')
], IOSSimulatorApplicationManager.prototype, "installApplication", null);
__decorate([
    decorators_1.cache()
], IOSSimulatorApplicationManager.prototype, "startDeviceLog", null);
exports.IOSSimulatorApplicationManager = IOSSimulatorApplicationManager;
